#+OPTIONS: ':nil *:t -:t ::t <:t H:nil \n:nil ^:nil arch:headline author:nil
#+OPTIONS: broken-links:nil c:nil creator:nil d:(not "LOGBOOK") date:nil e:t
#+OPTIONS: email:nil f:t inline:t num:nil p:nil pri:nil prop:nil stat:t tags:t
#+OPTIONS: tasks:t tex:t timestamp:nil title:t toc:nil todo:t |:t
#+TITLE:
#+AUTHOR:
#+EMAIL:
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS:
#+LATEX_HEADER:
#+LATEX_HEADER_EXTRA:
#+DESCRIPTION:
#+KEYWORDS:
#+SUBTITLE:
#+LATEX_COMPILER: pdflatex
#+DATE:
#+STARTUP: showall
#+OPTIONS: html-link-use-abs-url:nil html-postamble:nil html-preamble:tbla
#+OPTIONS: html-scripts:t html-style:t html5-fancy:nil tex:t
#+HTML_DOCTYPE: xhtml-strict
#+HTML_CONTAINER: div
#+DESCRIPTION:
#+KEYWORDS:
#+HTML_LINK_HOME:
#+HTML_LINK_UP:
#+HTML_MATHJAX:
#+HTML_HEAD:
#+HTML_HEAD_EXTRA:
#+SUBTITLE:
#+INFOJS_OPT:
#+OPTIONS: reveal_width:1600 reveal_height:900
#+REVEAL_TRANS: fade
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="./vivendi-tinted.css" />

#+REVEAL_MATHJAX_URL: https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML
#+REVEAL_EXTRA_CSS: ./vivendi-tinted.css
#+REVEAL_THEME: ./my_theme.css
#+REVEAL_EXTRA_CSS: ./footer.css
#+REVEAL_TITLE_SLIDE_BACKGROUND: ./async_title.png

#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js
#+REVEAL_VERSION: 4

#+REVEAL_HLEVEL: 2
#+REVEAL_EXPORT_NOTES_TO_PDF: separate-page

* Using Sender/Receiver for Async Control Flow

Steve Downey

© 2023 Bloomberg Finance L.P. All rights reserved.



* Abstract

How can P2300 Senders be composed using sender adapters and sender factories to provide arbitrary program control flow?

   #+ATTR_REVEAL: :frag (appear)
   - How do I use these things?
   #+ATTR_REVEAL: :frag (appear)
   - Where can I steal from?

#+begin_notes

#+end_notes

* ~std::execution~
[[https://wg21.link/P2300][P2300]]

Recent version at [[https://isocpp.org/files/papers/P2300R7.html][https://isocpp.org/files/papers/P2300R7.html]]

#+begin_quote
A self-contained design for a Standard C++ framework for managing asynchronous execution on generic execution resources.
#+end_quote

#+begin_notes

#+end_notes

** Three Key Abstractions
   #+ATTR_REVEAL: :frag (appear)
1. Schedulers
   #+ATTR_REVEAL: :frag (appear)
2. Senders
   #+ATTR_REVEAL: :frag (appear)
3. Receivers

*** Schedulers
Responsible for scheduling work on execution resources.

#+ATTR_REVEAL: :frag (appear)
Execution resources are things like threads, GPUs, and so on.

#+ATTR_REVEAL: :frag (appear)
Sends work to be done in a place.


#+begin_notes

#+end_notes

*** Senders
Senders describe work.

#+begin_notes

#+end_notes

*** Receivers

Receivers are where work terminates.

#+ATTR_REVEAL: :frag (appear)
- Value channel
 #+ATTR_REVEAL: :frag (appear)
- Error channel
 #+ATTR_REVEAL: :frag (appear)
- Stopped channel

#+begin_notes
Work can terminate in three different ways.
- Return a value.
- Throw an exception
- Be canceled

It's been a few minutes. Lets see some simple code.
#+end_notes

*** Hello Async World

#+begin_src C++ -n :tangle ./sender-examples/src/examples/hello.cpp :comments link

#include <stdexec/execution.hpp>
#include <exec/static_thread_pool.hpp>
#include <iostream>

int main() {
  exec::static_thread_pool pool(8);

  stdexec::scheduler auto sch = pool.get_scheduler();

  stdexec::sender auto begin = stdexec::schedule(sch);
  stdexec::sender auto hi    = stdexec::then(begin, [] {
    std::cout << "Hello world! Have an int.\n";
    return 13;
  });

  auto add_42 = stdexec::then(hi, [](int arg) { return arg + 42; });

  auto [i] = stdexec::sync_wait(add_42).value();

  std::cout << "The int is " << i << '\n';

  return 0;
}

#+end_src


[[https://godbolt.org/z/1M5enroaE][Compiler Explorer]]

#+begin_notes

#+end_notes

*** Hello Async World Results

#+RESULTS: hello
#+begin_example
Hello world! Have an int.
The int is 55
#+end_example

#+begin_notes

#+end_notes

*** When All - Concurent Async

#+BEGIN_SRC c++ :exports none :tangle ./sender-examples/src/examples/concurent.cpp :comments link
#include <stdexec/execution.hpp>
#include <exec/static_thread_pool.hpp>

int main()
{
#+END_SRC

#+begin_src c++ -n :tangle ./sender-examples/src/examples/concurent.cpp :comments link :exports code
exec::static_thread_pool pool(3);

auto sched = pool.get_scheduler();

auto fun = [](int i) { return i * i; };

auto work = stdexec::when_all(
    stdexec::on(sched, stdexec::just(0) | stdexec::then(fun)),
    stdexec::on(sched, stdexec::just(1) | stdexec::then(fun)),
    stdexec::on(sched, stdexec::just(2) | stdexec::then(fun)));

auto [i, j, k] = stdexec::sync_wait(std::move(work)).value();

std::printf("%d %d %d\n", i, j, k);
#+end_src

#+BEGIN_SRC c++ :exports none :tangle ./sender-examples/src/examples/concurent.cpp :comments link
}
#+END_SRC


#+begin_notes
Describe some work:

Creates 3 sender pipelines that are executed concurrently by passing to `when_all`

Each sender is scheduled on `sched` using `on` and starts with `just(n)` that
creates a Sender that just forwards `n` to the next sender.

After `just(n)`, we chain `then(fun)` which invokes `fun` using the value
provided from `just()`

Note: No work actually happens here. Everything is lazy and `work` is just an
object that statically represents the work to later be executed

#+end_notes

*** When All - Concurent Async - Results

#+RESULTS: concurent
#+begin_example
0 1 4
#+end_example

#+begin_notes
Order of execution is by chance, order of results is determined.
#+end_notes

*** Dynamic Choice of Sender

#+BEGIN_SRC c++ :exports none :tangle ./sender-examples/src/examples/let_value.cpp :comments link
#include <stdexec/execution.hpp>
#include <exec/static_thread_pool.hpp>
#include <string>

int main()
{
#+END_SRC

#+begin_src c++ -n :tangle ./sender-examples/src/examples/let_value.cpp :comments link :exports code
exec::static_thread_pool pool(3);

auto sched = pool.get_scheduler();

auto fun = [](int i) -> stdexec::sender auto {
  using namespace std::string_literals;
  if ((i % 2) == 0) {
    return stdexec::just("even"s);
  } else {
    return stdexec::just("odd"s);
  }
};

auto work = stdexec::when_all(
    stdexec::on(sched, stdexec::just(0) | stdexec::let_value(fun)),
    stdexec::on(sched, stdexec::just(1) | stdexec::let_value(fun)),
    stdexec::on(sched, stdexec::just(2) | stdexec::let_value(fun)));

auto [i, j, k] = stdexec::sync_wait(std::move(work)).value();

std::printf("%s %s %s", i.c_str(), j.c_str(), k.c_str());
#+end_src

#+BEGIN_SRC c++ :exports none :tangle ./sender-examples/src/examples/let_value.cpp :comments link
}
#+END_SRC


[[https://godbolt.org/z/7vx69cMj9][Compiler Explorer]]

#+RESULTS:

#+begin_notes

#+end_notes

*** Enough API to talk about control flow

The minimal set being:

- stdexec::on
- stdexec::just
- stdexec::then
- stdexec::let_value
- stdexec::sync_wait


I will mostly ignore the error and stop channels

#+begin_notes

#+end_notes

* Vigorous Handwaving

** Some Theory

Continuation Passing Style

#+begin_notes

#+end_notes

*** Not At All New

Sussman and Steele in 1975

[[https://dspace.mit.edu/bitstream/handle/1721.1/5794/AIM-349.pdf][AI Memo 349: "Scheme: An Interpreter for Extended Lambda Calculus"]]

#+begin_notes

#+end_notes

*** Pass a "Continuation"

Where to go next rather than return the value.

#+begin_src haskell
add :: Float -> Float -> Float
add a b = a + b

add_cps :: Float -> Float -> (Float -> a) -> a
add_cps a b cont = cont (a + b)
#+end_src

#+REVEAL: split

#+begin_src c++
auto add(float a, float b) -> float {
    return a + b;
}

template<typename Cont>
auto add_cps(float a, float b, Cont k) {
    return k(a+b);
}
#+end_src

#+begin_notes

#+end_notes

*** Inherently a tail call

In continuation passing style we never return.

We send a value to the rest of the program.

Hard to express in C++.

Extra machinery necessary to do the plumbing.

Also, some risk, so we don't always do TCO.

We keep the sender "thunks" live so we don't dangle references.

#+begin_notes

#+end_notes

*** Intermittently Popular as a Compiler Technique

The transformations of direct functions to CPS are mechanical.

The result is easier to optimize and mechanically reason about.

Equivalent to Single Static Assignment.

Structured Programming can be converted to CPS.

#+begin_notes

#+end_notes

*** Delimted Continuations
General continuations reified as a function.


#+begin_quote
Everyone knows that when a process executes a system call like ‘read’, it gets
suspended. When the disk delivers the data, the process is resumed. That
suspension of a process is its continuation. It is delimited: it is not the
check-point of the whole OS, it is the check-point of a process only, from the
invocation of main() up to the point main() returns. Normally these suspensions
are resumed only once, but can be zero times (exit) or twice (fork).
#+end_quote

Oleg Kiselyov
[[https://okmij.org/ftp/continuations/Fest2008-talk-notes.pdf][Fest2008-talk-notes.pdf]]

#+begin_notes
If this qoute reminds you of coroutines, you are paying attention.
#+end_notes

*** Haskell's Cont Type
#+begin_src haskell
newtype Cont r a = Cont { runCont :: (a -> r) -> r }
#+end_src

This is _roughly_ equivalent to the sender value channel.
A Cont takes a reciever, a function that consumes the value being sent, and produces an r, the result type.

The ~identity~ function is often used.

*** Underlies ~std::execution~

The plumbing is hidden.

Senders "send" to their continuations, delimted by the Reciever.

#+begin_notes

#+end_notes

** Another Level of Indirection

*** Solves all problems

#+ATTR_REVEAL: :frag (appear)
Adds two more.

#+ATTR_REVEAL: :frag (appear)
At least

#+begin_notes

#+end_notes

*** CPS Indirects Function Return

Transform a function

  \begin{equation}
  A  \rightarrow B
  \end{equation}


to

  \begin{equation}
  A  \rightarrow B  \rightarrow ( B \rightarrow R ) \rightarrow R
  \end{equation}


#+begin_src haskell
add :: Float -> Float -> Float
add a b = a + b

add_cps :: Float -> Float -> (Float -> A) -> A
add_cps a b cont = cont (a + b)
#+end_src


#+begin_notes

#+end_notes

*** Sender Closes Over A

  \begin{equation}
  B  \rightarrow ( B \rightarrow R ) \rightarrow R
  \end{equation}

  The $A$ is (mostly) erased from the Sender.

*** Reciever Is The Transform to Result

  \begin{equation}
  ( B \rightarrow R ) \rightarrow R
  \end{equation}

** Some Pictures
**** Sender

#+BEGIN_SRC ditaa :file images/sender.png :cmdline -r
+--------------+
|              |
|  +---+       |
|  | A |       |----> B
|  +---+       |
|              |
+--------------+

#+END_SRC

#+RESULTS:
[[file:images/sender.png]]

**** ~just~
#+begin_src c++
stdexec::just(0)
#+end_src

#+BEGIN_SRC ditaa :file images/just.png :cmdline -r
+--------------+
|              |
|              |   0
|              |------> B
|              |
|              |
+--------------+

#+END_SRC

#+RESULTS:
[[file:images/just.png]]

**** ~then~

#+begin_src c++
auto f(A a) -> B;
auto s = stdexec::just(a) | stdexec::then(f);
#+end_src

#+BEGIN_SRC ditaa :file images/then.png :cmdline -r
+--------------+
|              |
| +-+    a     |  f(a)
| | | -----> f |-------> B
| +-+          |
|              |
+--------------+
#+END_SRC

#+RESULTS:
[[file:images/then.png]]


**** ~let_value~

#+begin_src c++
sender_of<set_value_t(B)> auto snd(A a);
auto s = stdexec::just(a) | stdexec::let_value(snd);
#+end_src

#+BEGIN_SRC ditaa :file images/let_value.png :cmdline -r
+-------------------------+
|                         |
|                         |
| +-+  a          +--+ b  |  b
| | |----> snd--->|  |--->|-----> B
| +-+             +--+    |
|                         |
+-------------------------+
#+END_SRC

#+RESULTS:
[[file:images/let_value.png]]


** In which we use the M word

*** Sender is a Monad
#+ATTR_REVEAL: :frag (appear)
(surprise)
#+ATTR_REVEAL: :frag (appear)
(shock, dismay)

#+begin_notes

#+end_notes

*** Function Composition is the hint
Functions are units of work.

We compose them into programs.

The question is if the rules apply.

#+begin_notes

#+end_notes

*** Monadic Interface

- bind or and_then ::
  \begin{equation}
  M \langle a \rangle \rightarrow (a \rightarrow M \langle b \rangle ) \rightarrow M \langle b \rangle
  \end{equation}

- fish or kleisli arrow  ::
  \begin{equation}
  (a \rightarrow M \langle b \rangle ) \rightarrow (b \rightarrow M \langle c \rangle ) \rightarrow (a \rightarrow M \langle c \rangle )
  \end{equation}

- join or flatten or mconcat ::
  \begin{equation}
  M \langle M \langle a \rangle \rangle \rightarrow  M \langle a \rangle
  \end{equation}

#+begin_notes
Monad Interface
#+end_notes

*** Applicative and Functor parts

- make or pure or return ::
  \begin{equation}
  a  \rightarrow  M \langle a \rangle
  \end{equation}

- fmap or transform ::
   \begin{equation}
    (a \rightarrow b) \rightarrow M \langle a \rangle \rightarrow M \langle b \rangle
   \end{equation}

Any one of the first three and one of the second two can define the other three

#+begin_notes
Monad Interface
#+end_notes
*** Monad Laws

- left identity :: bind(pure(a), h) == h(a)
- right identity :: bind(m, pure) == m
- associativity :: bind(bind(m, g), h) == bind(m, bind((\x -> g(x), h))

#+begin_notes
Monad Laws
#+end_notes

*** Sender is Three Monads in a Trench-coat

Stacked up.

- Value
- Error
- Stopped

#+begin_notes
The three channels can be crossed, mixed, and remixed. Focus on the value channel for simplicity.
#+end_notes

** The Three Monadic Parts

#+begin_notes

#+end_notes

*** ~just~
Send a value.

~pure~

#+begin_notes
just lifts a value into the monad
#+end_notes

*** ~then~
Send a value returned from a function that takes its argument from a Sender.

~fmap~ or ~transform~

#+begin_notes
then is the functor fmap
#+end_notes

*** ~let_value~
Send what is returned by a Sender returned from a function that takes its argument from a Sender.

~bind~

#+begin_notes
let value is the monadic bind
#+end_notes

*** Necessary and Sufficient

The monadic bind gives us the runtime choices we need.

#+begin_notes

#+end_notes

** Basis of Control
- Sequence
- Decision
- Recursion

#+begin_notes

#+end_notes

*** Sequence

#+begin_src c++ -n
  stdexec::sender auto work =
      stdexec::schedule(sch)
      | stdexec::then([] {
          std::cout << "Hello world! Have an int.";
          return 13;
      })
      | stdexec::then([](int arg) { return arg + 42; });

  auto [i] = stdexec::sync_wait(work).value();

#+end_src

#+begin_notes
One thing after another.
#+end_notes

*** Decision
#+BEGIN_SRC c++ :exports none :tangle ./sender-examples/src/examples/decision.cpp :comments link
#include <stdexec/execution.hpp>
#include <exec/static_thread_pool.hpp>
#include <exec/any_sender_of.hpp>
#include <exec/variant_sender.hpp>
#include <iostream>

template <class... Ts>
using any_sender_of =
    typename exec::any_receiver_ref<
        stdexec::completion_signatures<Ts...>>::
        template any_sender<>;

inline auto tst = [](bool                 cond,
                     stdexec::sender auto left,
                     stdexec::sender auto right)
    -> exec::variant_sender<decltype(left),
                            decltype(right)> {
  if (cond)
    return left;
  else
    return right;
};

int main() {
#+END_SRC

#+begin_src c++ -n :tangle ./sender-examples/src/examples/decision.cpp :comments link :exports code
exec::static_thread_pool pool(8);

stdexec::scheduler auto sch = pool.get_scheduler();

stdexec::sender auto begin  = stdexec::schedule(sch);
stdexec::sender auto seven  = stdexec::just(7);
stdexec::sender auto eleven = stdexec::just(11);

stdexec::sender auto branch =
    begin
    | stdexec::then([]() { return std::make_tuple(5, 4); })
    | stdexec::let_value(
        [=](auto tpl) {
        auto const& [i, j] = tpl;

        return tst((i > j),
                   seven | stdexec::then([&](int k) noexcept {
                       std::cout << "true branch " << k << '\n';
                   }),
                   eleven | stdexec::then([&](int k) noexcept {
                       std::cout << "false branch " << k << '\n';
                   }));
    });

stdexec::sync_wait(std::move(branch));
#+end_src

#+BEGIN_SRC c++ :exports none :tangle ./sender-examples/src/examples/decision.cpp :comments link
}
#+END_SRC

#+REVEAL: split

#+RESULTS: decision
#+begin_example
true branch 7
#+end_example

#+begin_notes
Control what sender is sent at rentime depending on the state of the program when the work is executing rather than in the structure of the senders.
#+end_notes

**** ~tst~ function
#+BEGIN_SRC c++ -n :exports code

inline auto tst =
    [](bool                 cond,
       stdexec::sender auto left,
       stdexec::sender auto right) -> any_sender_of<stdexec::set_value_t()> {
    if (cond)
        return left;
    else
        return right;
};


#+END_SRC

*** Recursion

#+begin_notes

#+end_notes

**** Simple Recursion
#+begin_src c++ :exports none :tangle ./sender-examples/src/examples/factorial.cpp :comments link
#include <cassert>
#include <stdexec/execution.hpp>
#include <exec/static_thread_pool.hpp>
#include <exec/any_sender_of.hpp>
#include <iostream>

template <class... Ts>
using any_sender_of = typename exec::any_receiver_ref<
    stdexec::completion_signatures<Ts...>>::template any_sender<>;



#+END_SRC

#+begin_src c++ -n :tangle ./sender-examples/src/examples/factorial.cpp :comments link :exports code

using any_int_sender =
    any_sender_of<stdexec::set_value_t(int),
                  stdexec::set_stopped_t(),
                  stdexec::set_error_t(std::exception_ptr)>;

auto fac(int n) -> any_int_sender {
    std::cout << "factorial of " << n << "\n";
    if (n == 0)
        return stdexec::just(1);

    return stdexec::just(n - 1)
        | stdexec::let_value([](int k) { return fac(k); })
        | stdexec::then([n](int k) { return k * n; });
}

#+end_src

#+BEGIN_SRC c++ :exports none :tangle ./sender-examples/src/examples/factorial.cpp :comments link

int main() {
    exec::static_thread_pool pool(8);

    stdexec::scheduler auto sch = pool.get_scheduler();

    stdexec::sender auto begin = stdexec::schedule(sch);

#+END_SRC

#+REVEAL: split

#+begin_src c++ -n :tangle ./sender-examples/src/examples/factorial.cpp :comments link :exports code

    int                  k = 10;
    stdexec::sender auto factorial =
        begin
        | stdexec::then([=]() { return k; })
        | stdexec::let_value([](int k) { return fac(k); });

    std::cout << "factorial built\n\n";

    auto [i] = stdexec::sync_wait(std::move(factorial)).value();
    std::cout << "factorial " << k << " = " << i << '\n';

#+end_src

#+BEGIN_SRC c++ :exports none :tangle ./sender-examples/src/examples/factorial.cpp :comments link
    }

#+END_SRC

#+REVEAL: split

#+RESULTS: factorial
#+begin_example
factorial built

factorial of 10
factorial of 9
factorial of 8
factorial of 7
factorial of 6
factorial of 5
factorial of 4
factorial of 3
factorial of 2
factorial of 1
factorial of 0
factorial 10 = 3628800
#+end_example

**** General Recursion
#+begin_src c++ :exports none :tangle ./sender-examples/src/examples/fibonacci.cpp :comments link
#include <cassert>
#include <stdexec/execution.hpp>
#include <exec/static_thread_pool.hpp>
#include <exec/any_sender_of.hpp>
#include <iostream>

auto getDefaultPool() -> exec::static_thread_pool& {
    static exec::static_thread_pool pool(1);
    return pool;
}

auto getDefaultScheduler() -> stdexec::scheduler auto& {
    static stdexec::scheduler auto sch = getDefaultPool().get_scheduler();
    return sch;
}

template <class... Ts>
using any_sender_of = typename exec::any_receiver_ref<
    stdexec::completion_signatures<Ts...>>::template any_sender<>;

using any_int_sender = any_sender_of<stdexec::set_value_t(int),
                                     stdexec::set_stopped_t(),
                                     stdexec::set_error_t(std::exception_ptr)>;
#+END_SRC

#+begin_src c++ -n :tangle ./sender-examples/src/examples/fibonacci.cpp :comments link :exports code
auto fib(int n) -> any_int_sender {
    if (n == 0)
        return stdexec::on(getDefaultScheduler(),  stdexec::just(0));

    if (n == 1)
        return stdexec::on(getDefaultScheduler(), stdexec::just(1));

    auto work = stdexec::when_all(
                    stdexec::on(getDefaultScheduler(), stdexec::just(n - 1)) |
                        stdexec::let_value([](int k) { return fib(k); }),
                    stdexec::on(getDefaultScheduler(), stdexec::just(n - 2)) |
                        stdexec::let_value([](int k) { return fib(k); })) |
                stdexec::then([](auto i, auto j) { return i + j; });

    return work;
}

#+end_src

#+BEGIN_SRC c++ :exports none :tangle ./sender-examples/src/examples/fibonacci.cpp :comments link
auto fibr(int n) -> int {
    if (n == 0)
        return 0;

    if (n == 1)
        return 1;

    return fibr(n - 1) + fibr(n - 2);
}

int main() {
    stdexec::scheduler auto sch = getDefaultScheduler();

    stdexec::sender auto begin = stdexec::schedule(sch);
#+END_SRC

#+REVEAL: split

#+begin_src c++ -n :tangle ./sender-examples/src/examples/fibonacci.cpp :comments link :exports code

int                  k = 30;
    stdexec::sender auto fibonacci =
        begin | stdexec::then([=]() { return k; }) |
        stdexec::let_value([](int k) { return fib(k); });

    std::cout << "fibonacci built\n";

    auto [i] = stdexec::sync_wait(std::move(fibonacci)).value();
    std::cout << "fibonacci " << k << " = " << i << '\n';
#+end_src

#+BEGIN_SRC c++ :exports none :tangle ./sender-examples/src/examples/fibonacci.cpp :comments link
    std::cout << "fibonacci " << k << " = " << fibr(k) << '\n';
}

#+end_src

#+REVEAL: split

#+RESULTS: fibonacci
#+begin_example
fibonacci built
fibonacci 30 = 832040
fibonacci 30 = 832040
#+end_example

**** Fold
#+begin_src c++ :exports none :tangle ./sender-examples/src/examples/fold.cpp :comments link
#include <cassert>
#include <stdexec/execution.hpp>
#include <exec/static_thread_pool.hpp>
#include <exec/any_sender_of.hpp>
#include <iostream>
#include <ranges>

template <class... Ts>
using any_sender_of = typename exec::any_receiver_ref<
    stdexec::completion_signatures<Ts...>>::template any_sender<>;

using any_int_sender = any_sender_of<stdexec::set_value_t(int),
                                     stdexec::set_stopped_t(),
                                     stdexec::set_error_t(std::exception_ptr)>;

struct fold_left_fn {
    template <std::input_iterator I, std::sentinel_for<I> S, class T, class F>
    constexpr auto operator()(I first, S last, T init, F f) const
        -> any_sender_of<
            stdexec::set_value_t(
                std::decay_t<
                    std::invoke_result_t<F&, T, std::iter_reference_t<I>>>),
            stdexec::set_stopped_t(),
            stdexec::set_error_t(std::exception_ptr)> {
        using U = std::decay_t<
            std::invoke_result_t<F&, T, std::iter_reference_t<I>>>;
#+END_SRC

#+begin_src c++ -n :tangle ./sender-examples/src/examples/fold.cpp :comments link :exports code

        if (first == last) {
            return stdexec::just(U(std::move(init)));
        }

        auto nxt =
            stdexec::just(std::invoke(f, std::move(init), *first)) |
            stdexec::let_value([this,
                                first = first,
                                last = last,
                                f = f
                                ](U u) {
                I i = first;
                return (*this)(++i, last, u, f);
            });
        return std::move(nxt);
#+end_src

#+BEGIN_SRC c++ :exports none :tangle ./sender-examples/src/examples/fold.cpp :comments link
    }

    template <std::ranges::input_range R, class T, class F>
    constexpr auto operator()(R&& r, T init, F f) const {
        return (*this)(std::ranges::begin(r),
                       std::ranges::end(r),
                       std::move(init),
                       std::ref(f));
    }
};

inline constexpr fold_left_fn fold_left;

int main() {
    exec::static_thread_pool pool(1);

    stdexec::scheduler auto sch = pool.get_scheduler();

    stdexec::sender auto begin = stdexec::schedule(sch);
#+END_SRC

#+REVEAL: split

#+begin_src c++ -n :tangle ./sender-examples/src/examples/fold.cpp :comments link :exports code

    auto v = std::ranges::iota_view{1, 10'000};

    stdexec::sender auto work =
        begin
        | stdexec::let_value([i = std::ranges::begin(v),
                              s = std::ranges::end(v)]() {
            return fold_left(i, s, 0, [](int i, int j) { return i + j; });
        });

    auto [i] = stdexec::sync_wait(std::move(work)).value();

#+end_src

#+BEGIN_SRC c++ :exports none :tangle ./sender-examples/src/examples/fold.cpp :comments link
    std::cout << "work " << " = " << i << '\n';
}
#+end_src

#+REVEAL: split

#+RESULTS: fold
#+begin_example
work  = 49995000
#+end_example

**** Backtrack
#+begin_src c++ :exports none :tangle ./sender-examples/src/examples/backtrack.cpp :comments link
#include <cassert>

#include <stdexec/execution.hpp>
#include <exec/static_thread_pool.hpp>
#include <exec/any_sender_of.hpp>
#include <tree/tree.h>

#include <iostream>
#include <ranges>

template <class... Ts>
using any_sender_of = typename exec::any_receiver_ref<
    stdexec::completion_signatures<Ts...>>::template any_sender<>;

using any_int_sender = any_sender_of<stdexec::set_value_t(int),
                                     stdexec::set_stopped_t(),
                                     stdexec::set_error_t(std::exception_ptr)>;
#+end_src


#+begin_src c++ :exports code :tangle ./sender-examples/src/examples/backtrack.cpp :comments link
using any_node_sender =
    any_sender_of<stdexec::set_value_t(tree::NodePtr<int>),
                  stdexec::set_stopped_t(),
                  stdexec::set_error_t(std::exception_ptr)>;

auto search_tree(auto                    test,
                 tree::NodePtr<int>      tree,
                 stdexec::scheduler auto sch,
                 any_node_sender&&       fail) -> any_node_sender {
    if (tree == nullptr) {
        return std::move(fail);
    }
    if (test(tree)) {
        return stdexec::just(tree);
    }
    return stdexec::on(sch, stdexec::just()) |
           stdexec::let_value([=, fail = std::move(fail)]() mutable {
               return search_tree(
                   test,
                   tree->left(),
                   sch,
                   stdexec::on(sch, stdexec::just()) |
                       stdexec::let_value(
                           [=, fail = std::move(fail)]() mutable {
                               return search_tree(
                                   test, tree->right(), sch, std::move(fail));
                           }));
           });
    return fail;
}
#+end_src

#+REVEAL: split

#+begin_src c++ :exports none :tangle ./sender-examples/src/examples/backtrack.cpp :comments link
int main() {
    exec::static_thread_pool pool(8);

    stdexec::scheduler auto sch = pool.get_scheduler();

    stdexec::sender auto begin = stdexec::schedule(sch);
#+end_src

#+begin_src c++ :tangle ./sender-examples/src/examples/backtrack.cpp :comments link :exports code
    tree::NodePtr<int> t;
    for (auto i : std::ranges::views::iota(1, 10'000)) {
        tree::Tree<int>::insert(i, t);
    }

    auto test = [](tree::NodePtr<int> t) -> bool {
        return t ? t->data() == 500 : false;
    };

    auto fail = begin | stdexec::then([]() { return tree::NodePtr<int>{}; });

    stdexec::sender auto work =
        begin | stdexec::let_value([=]() {
            return search_tree(test, t, sch, std::move(fail));
        });

    auto [n] = stdexec::sync_wait(std::move(work)).value();

    std::cout << "work "
              << " = " << n->data() << '\n';
#+end_src

#+begin_src c++ :exports none :tangle ./sender-examples/src/examples/backtrack.cpp :comments link
}
#+end_src

#+REVEAL: split

#+RESULTS: backtrack
#+begin_example
work  = 500
#+end_example

* Don't Do That
** Can is not Should
** Write an Algorithm
** Why You Might
- Throughput
- Interruptable


#+begin_notes

#+end_notes

* Thank You

#+begin_notes

#+end_notes

* Tangle before export                                             :noexport:
To retangle the document, run `C-c C-v t` or eval the last src block

#+NAME: run-build
#+BEGIN_SRC sh :exports both :results output
cd sender-examples
make realclean TOOLCHAIN=clang-15
make TOOLCHAIN=clang-15
make test TOOLCHAIN=clang-15
make install TOOLCHAIN=clang-15
#+END_SRC

#+RESULTS: run-build
#+begin_example
make -f targets.mk realclean CONFIG= TOOLCHAIN=clang-15
make[1]: Entering directory '/home/sdowney/src/papers/cppnow23/sender-examples'
rm -rf ../cmake.bld/sender-examples/build-clang-15
make[1]: Leaving directory '/home/sdowney/src/papers/cppnow23/sender-examples'
make -f targets.mk test CONFIG= TOOLCHAIN=clang-15
make[1]: Entering directory '/home/sdowney/src/papers/cppnow23/sender-examples'
mkdir -p ../cmake.bld/sender-examples/build-clang-15
cd ../cmake.bld/sender-examples/build-clang-15 && 	cmake -G "Ninja Multi-Config" -DCMAKE_CONFIGURATION_TYPES="RelWithDebInfo;Debug;Tsan;Asan" -DCMAKE_INSTALL_PREFIX= -DCMAKE_EXPORT_COMPILE_COMMANDS=1 -DCMAKE_TOOLCHAIN_FILE=/home/sdowney/src/papers/cppnow23/sender-examples/etc/clang-15-toolchain.cmake /home/sdowney/src/papers/cppnow23/sender-examples
-- The CXX compiler identification is Clang 15.0.7
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Check for working CXX compiler: /usr/bin/clang++-15 - skipped
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- The C compiler identification is Clang 15.0.7
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working C compiler: /usr/bin/clang-15 - skipped
-- Detecting C compile features
-- Detecting C compile features - done
-- Found Python: /usr/bin/python3 (found version "3.11.2") found components: Interpreter
-- Performing Test CMAKE_HAVE_LIBC_PTHREAD
-- Performing Test CMAKE_HAVE_LIBC_PTHREAD - Success
-- Found Threads: TRUE
-- System           : Linux-6.2.0-20-generic
-- System name      : Linux
-- System ver       : 6.2.0-20-generic
--
-- Library ver      : 0.8.0
-- Build date       : 2023-05-06
-- Build year       : 2023
--
-- CPM: adding package Catch2@2.13.6 (2.13.6)
-- Configuring done
-- Generating done
-- Build files have been written to: /home/sdowney/src/papers/cppnow23/cmake.bld/sender-examples/build-clang-15
rm compile_commands.json
ln -s ../cmake.bld/sender-examples/build-clang-15/compile_commands.json
cmake --build ../cmake.bld/sender-examples/build-clang-15  --config RelWithDebInfo --target all -v -- -k 0
[1/32] /usr/bin/clang++-15 -DCMAKE_INTDIR=\"RelWithDebInfo\" -I/home/sdowney/src/papers/cppnow23/sender-examples/src/scratch/.. -std=c++20    -Wall    -stdlib=libc++  -O3 -g -DNDEBUG -MD -MT src/scratch/CMakeFiles/scratch.dir/RelWithDebInfo/scratch.cpp.o -MF src/scratch/CMakeFiles/scratch.dir/RelWithDebInfo/scratch.cpp.o.d -o src/scratch/CMakeFiles/scratch.dir/RelWithDebInfo/scratch.cpp.o -c /home/sdowney/src/papers/cppnow23/sender-examples/src/scratch/scratch.cpp
[2/32] : && /usr/bin/cmake -E rm -f src/scratch/RelWithDebInfo/libscratch.a && /usr/bin/llvm-ar-15 qc src/scratch/RelWithDebInfo/libscratch.a  src/scratch/CMakeFiles/scratch.dir/RelWithDebInfo/scratch.cpp.o && /usr/bin/llvm-ranlib-15 src/scratch/RelWithDebInfo/libscratch.a && :
[3/32] /usr/bin/clang++-15 -DCMAKE_INTDIR=\"RelWithDebInfo\" -I/home/sdowney/src/papers/cppnow23/sender-examples/src/tree/.. -std=c++20    -Wall    -stdlib=libc++  -O3 -g -DNDEBUG -MD -MT src/tree/CMakeFiles/tree.dir/RelWithDebInfo/tree.cpp.o -MF src/tree/CMakeFiles/tree.dir/RelWithDebInfo/tree.cpp.o.d -o src/tree/CMakeFiles/tree.dir/RelWithDebInfo/tree.cpp.o -c /home/sdowney/src/papers/cppnow23/sender-examples/src/tree/tree.cpp
[4/32] : && /usr/bin/cmake -E rm -f src/tree/RelWithDebInfo/libtree.a && /usr/bin/llvm-ar-15 qc src/tree/RelWithDebInfo/libtree.a  src/tree/CMakeFiles/tree.dir/RelWithDebInfo/tree.cpp.o && /usr/bin/llvm-ranlib-15 src/tree/RelWithDebInfo/libtree.a && :
[5/32] /usr/bin/clang++-15 -DCMAKE_INTDIR=\"RelWithDebInfo\" -I/home/sdowney/src/papers/cppnow23/sender-examples/src/scratch/.. -std=c++20    -Wall    -stdlib=libc++  -O3 -g -DNDEBUG -MD -MT src/examples/CMakeFiles/main.dir/RelWithDebInfo/main.cpp.o -MF src/examples/CMakeFiles/main.dir/RelWithDebInfo/main.cpp.o.d -o src/examples/CMakeFiles/main.dir/RelWithDebInfo/main.cpp.o -c /home/sdowney/src/papers/cppnow23/sender-examples/src/examples/main.cpp
[6/32] : && /usr/bin/clang++-15 -std=c++20    -Wall    -stdlib=libc++  -O3 -g -DNDEBUG  src/examples/CMakeFiles/main.dir/RelWithDebInfo/main.cpp.o -o src/examples/RelWithDebInfo/main  src/scratch/RelWithDebInfo/libscratch.a && :
[7/32] /usr/bin/clang++-15 -DCMAKE_INTDIR=\"RelWithDebInfo\" -isystem /home/sdowney/src/papers/cppnow23/sender-examples/extern/googletest/googletest/include -isystem /home/sdowney/src/papers/cppnow23/sender-examples/extern/googletest/googletest -std=c++20    -Wall    -stdlib=libc++  -O3 -g -DNDEBUG -Wall -Wshadow -Wconversion -Wundef -DGTEST_HAS_PTHREAD=1 -fexceptions -W -Wpointer-arith -Wreturn-type -Wcast-qual -Wwrite-strings -Wswitch -Wunused-parameter -Wcast-align -Wchar-subscripts -Winline -Wredundant-decls -MD -MT extern/googletest/googletest/CMakeFiles/gtest_main.dir/RelWithDebInfo/src/gtest_main.cc.o -MF extern/googletest/googletest/CMakeFiles/gtest_main.dir/RelWithDebInfo/src/gtest_main.cc.o.d -o extern/googletest/googletest/CMakeFiles/gtest_main.dir/RelWithDebInfo/src/gtest_main.cc.o -c /home/sdowney/src/papers/cppnow23/sender-examples/extern/googletest/googletest/src/gtest_main.cc
[8/32] /usr/bin/clang++-15 -DCMAKE_INTDIR=\"RelWithDebInfo\" -I/home/sdowney/src/papers/cppnow23/sender-examples/extern/stdexec/include -std=c++20    -Wall    -stdlib=libc++  -O3 -g -DNDEBUG -MD -MT src/examples/CMakeFiles/hello.dir/RelWithDebInfo/hello.cpp.o -MF src/examples/CMakeFiles/hello.dir/RelWithDebInfo/hello.cpp.o.d -o src/examples/CMakeFiles/hello.dir/RelWithDebInfo/hello.cpp.o -c /home/sdowney/src/papers/cppnow23/sender-examples/src/examples/hello.cpp
[9/32] /usr/bin/clang++-15 -DCMAKE_INTDIR=\"RelWithDebInfo\" -I/home/sdowney/src/papers/cppnow23/sender-examples/src/scratch/.. -isystem /home/sdowney/src/papers/cppnow23/sender-examples/extern/googletest/googletest/include -isystem /home/sdowney/src/papers/cppnow23/sender-examples/extern/googletest/googletest -std=c++20    -Wall    -stdlib=libc++  -O3 -g -DNDEBUG -MD -MT src/scratch/CMakeFiles/scratch_test.dir/RelWithDebInfo/scratch.t.cpp.o -MF src/scratch/CMakeFiles/scratch_test.dir/RelWithDebInfo/scratch.t.cpp.o.d -o src/scratch/CMakeFiles/scratch_test.dir/RelWithDebInfo/scratch.t.cpp.o -c /home/sdowney/src/papers/cppnow23/sender-examples/src/scratch/scratch.t.cpp
[10/32] : && /usr/bin/clang++-15 -std=c++20    -Wall    -stdlib=libc++  -O3 -g -DNDEBUG  src/examples/CMakeFiles/hello.dir/RelWithDebInfo/hello.cpp.o -o src/examples/RelWithDebInfo/hello   && :
[11/32] /usr/bin/clang++-15 -DCMAKE_INTDIR=\"RelWithDebInfo\" -I/home/sdowney/src/papers/cppnow23/sender-examples/extern/stdexec/include -std=c++20    -Wall    -stdlib=libc++  -O3 -g -DNDEBUG -MD -MT src/examples/CMakeFiles/concurent.dir/RelWithDebInfo/concurent.cpp.o -MF src/examples/CMakeFiles/concurent.dir/RelWithDebInfo/concurent.cpp.o.d -o src/examples/CMakeFiles/concurent.dir/RelWithDebInfo/concurent.cpp.o -c /home/sdowney/src/papers/cppnow23/sender-examples/src/examples/concurent.cpp
[12/32] : && /usr/bin/clang++-15 -std=c++20    -Wall    -stdlib=libc++  -O3 -g -DNDEBUG  src/examples/CMakeFiles/concurent.dir/RelWithDebInfo/concurent.cpp.o -o src/examples/RelWithDebInfo/concurent   && :
[13/32] /usr/bin/clang++-15 -DCMAKE_INTDIR=\"RelWithDebInfo\" -I/home/sdowney/src/papers/cppnow23/sender-examples/src/tree/.. -isystem /home/sdowney/src/papers/cppnow23/sender-examples/extern/googletest/googletest/include -isystem /home/sdowney/src/papers/cppnow23/sender-examples/extern/googletest/googletest -std=c++20    -Wall    -stdlib=libc++  -O3 -g -DNDEBUG -MD -MT src/tree/CMakeFiles/tree_test.dir/RelWithDebInfo/tree.t.cpp.o -MF src/tree/CMakeFiles/tree_test.dir/RelWithDebInfo/tree.t.cpp.o.d -o src/tree/CMakeFiles/tree_test.dir/RelWithDebInfo/tree.t.cpp.o -c /home/sdowney/src/papers/cppnow23/sender-examples/src/tree/tree.t.cpp
[14/32] /usr/bin/clang++-15 -DCMAKE_INTDIR=\"RelWithDebInfo\" -I/home/sdowney/src/papers/cppnow23/sender-examples/extern/stdexec/include -std=c++20    -Wall    -stdlib=libc++  -O3 -g -DNDEBUG -MD -MT src/examples/CMakeFiles/decision.dir/RelWithDebInfo/decision.cpp.o -MF src/examples/CMakeFiles/decision.dir/RelWithDebInfo/decision.cpp.o.d -o src/examples/CMakeFiles/decision.dir/RelWithDebInfo/decision.cpp.o -c /home/sdowney/src/papers/cppnow23/sender-examples/src/examples/decision.cpp
[15/32] : && /usr/bin/clang++-15 -std=c++20    -Wall    -stdlib=libc++  -O3 -g -DNDEBUG  src/examples/CMakeFiles/decision.dir/RelWithDebInfo/decision.cpp.o -o src/examples/RelWithDebInfo/decision   && :
[16/32] /usr/bin/clang++-15 -DCMAKE_INTDIR=\"RelWithDebInfo\" -I/home/sdowney/src/papers/cppnow23/sender-examples/extern/stdexec/include -std=c++20    -Wall    -stdlib=libc++  -O3 -g -DNDEBUG -MD -MT src/examples/CMakeFiles/factorial.dir/RelWithDebInfo/factorial.cpp.o -MF src/examples/CMakeFiles/factorial.dir/RelWithDebInfo/factorial.cpp.o.d -o src/examples/CMakeFiles/factorial.dir/RelWithDebInfo/factorial.cpp.o -c /home/sdowney/src/papers/cppnow23/sender-examples/src/examples/factorial.cpp
[17/32] /usr/bin/clang++-15 -DCMAKE_INTDIR=\"RelWithDebInfo\" -I/home/sdowney/src/papers/cppnow23/sender-examples/extern/stdexec/include -std=c++20    -Wall    -stdlib=libc++  -O3 -g -DNDEBUG -MD -MT src/examples/CMakeFiles/let_value.dir/RelWithDebInfo/let_value.cpp.o -MF src/examples/CMakeFiles/let_value.dir/RelWithDebInfo/let_value.cpp.o.d -o src/examples/CMakeFiles/let_value.dir/RelWithDebInfo/let_value.cpp.o -c /home/sdowney/src/papers/cppnow23/sender-examples/src/examples/let_value.cpp
[18/32] : && /usr/bin/clang++-15 -std=c++20    -Wall    -stdlib=libc++  -O3 -g -DNDEBUG  src/examples/CMakeFiles/factorial.dir/RelWithDebInfo/factorial.cpp.o -o src/examples/RelWithDebInfo/factorial   && :
[19/32] : && /usr/bin/clang++-15 -std=c++20    -Wall    -stdlib=libc++  -O3 -g -DNDEBUG  src/examples/CMakeFiles/let_value.dir/RelWithDebInfo/let_value.cpp.o -o src/examples/RelWithDebInfo/let_value   && :
[20/32] /usr/bin/clang++-15 -DCMAKE_INTDIR=\"RelWithDebInfo\" -I/home/sdowney/src/papers/cppnow23/sender-examples/extern/stdexec/include -std=c++20    -Wall    -stdlib=libc++  -O3 -g -DNDEBUG -MD -MT src/examples/CMakeFiles/fold.dir/RelWithDebInfo/fold.cpp.o -MF src/examples/CMakeFiles/fold.dir/RelWithDebInfo/fold.cpp.o.d -o src/examples/CMakeFiles/fold.dir/RelWithDebInfo/fold.cpp.o -c /home/sdowney/src/papers/cppnow23/sender-examples/src/examples/fold.cpp
[21/32] : && /usr/bin/clang++-15 -std=c++20    -Wall    -stdlib=libc++  -O3 -g -DNDEBUG  src/examples/CMakeFiles/fold.dir/RelWithDebInfo/fold.cpp.o -o src/examples/RelWithDebInfo/fold   && :
[22/32] /usr/bin/clang++-15 -DCMAKE_INTDIR=\"RelWithDebInfo\" -I/home/sdowney/src/papers/cppnow23/sender-examples/extern/stdexec/include -std=c++20    -Wall    -stdlib=libc++  -O3 -g -DNDEBUG -MD -MT src/examples/CMakeFiles/fibonacci.dir/RelWithDebInfo/fibonacci.cpp.o -MF src/examples/CMakeFiles/fibonacci.dir/RelWithDebInfo/fibonacci.cpp.o.d -o src/examples/CMakeFiles/fibonacci.dir/RelWithDebInfo/fibonacci.cpp.o -c /home/sdowney/src/papers/cppnow23/sender-examples/src/examples/fibonacci.cpp
[23/32] : && /usr/bin/clang++-15 -std=c++20    -Wall    -stdlib=libc++  -O3 -g -DNDEBUG  src/examples/CMakeFiles/fibonacci.dir/RelWithDebInfo/fibonacci.cpp.o -o src/examples/RelWithDebInfo/fibonacci   && :
[24/32] /usr/bin/clang++-15 -DCMAKE_INTDIR=\"RelWithDebInfo\" -I/home/sdowney/src/papers/cppnow23/sender-examples/extern/stdexec/include -isystem /home/sdowney/src/papers/cppnow23/sender-examples/extern/googletest/googletest/include -isystem /home/sdowney/src/papers/cppnow23/sender-examples/extern/googletest/googletest -std=c++20    -Wall    -stdlib=libc++  -O3 -g -DNDEBUG -MD -MT src/examples/CMakeFiles/async_test.dir/RelWithDebInfo/async.t.cpp.o -MF src/examples/CMakeFiles/async_test.dir/RelWithDebInfo/async.t.cpp.o.d -o src/examples/CMakeFiles/async_test.dir/RelWithDebInfo/async.t.cpp.o -c /home/sdowney/src/papers/cppnow23/sender-examples/src/examples/async.t.cpp
[25/32] /usr/bin/clang++-15 -DCMAKE_INTDIR=\"RelWithDebInfo\" -I/home/sdowney/src/papers/cppnow23/sender-examples/extern/stdexec/include -I/home/sdowney/src/papers/cppnow23/sender-examples/src/tree/.. -std=c++20    -Wall    -stdlib=libc++  -O3 -g -DNDEBUG -MD -MT src/examples/CMakeFiles/backtrack.dir/RelWithDebInfo/backtrack.cpp.o -MF src/examples/CMakeFiles/backtrack.dir/RelWithDebInfo/backtrack.cpp.o.d -o src/examples/CMakeFiles/backtrack.dir/RelWithDebInfo/backtrack.cpp.o -c /home/sdowney/src/papers/cppnow23/sender-examples/src/examples/backtrack.cpp
[26/32] : && /usr/bin/clang++-15 -std=c++20    -Wall    -stdlib=libc++  -O3 -g -DNDEBUG  src/examples/CMakeFiles/backtrack.dir/RelWithDebInfo/backtrack.cpp.o -o src/examples/RelWithDebInfo/backtrack  src/tree/RelWithDebInfo/libtree.a && :
[27/32] /usr/bin/clang++-15 -DCMAKE_INTDIR=\"RelWithDebInfo\" -I/home/sdowney/src/papers/cppnow23/sender-examples/extern/googletest/googletest/include -I/home/sdowney/src/papers/cppnow23/sender-examples/extern/googletest/googletest -std=c++20    -Wall    -stdlib=libc++  -O3 -g -DNDEBUG -Wall -Wshadow -Wconversion -Wundef -DGTEST_HAS_PTHREAD=1 -fexceptions -W -Wpointer-arith -Wreturn-type -Wcast-qual -Wwrite-strings -Wswitch -Wunused-parameter -Wcast-align -Wchar-subscripts -Winline -Wredundant-decls -MD -MT extern/googletest/googletest/CMakeFiles/gtest.dir/RelWithDebInfo/src/gtest-all.cc.o -MF extern/googletest/googletest/CMakeFiles/gtest.dir/RelWithDebInfo/src/gtest-all.cc.o.d -o extern/googletest/googletest/CMakeFiles/gtest.dir/RelWithDebInfo/src/gtest-all.cc.o -c /home/sdowney/src/papers/cppnow23/sender-examples/extern/googletest/googletest/src/gtest-all.cc
[28/32] : && /usr/bin/cmake -E rm -f lib/RelWithDebInfo/libgtest.a && /usr/bin/llvm-ar-15 qc lib/RelWithDebInfo/libgtest.a  extern/googletest/googletest/CMakeFiles/gtest.dir/RelWithDebInfo/src/gtest-all.cc.o && /usr/bin/llvm-ranlib-15 lib/RelWithDebInfo/libgtest.a && :
[29/32] : && /usr/bin/cmake -E rm -f lib/RelWithDebInfo/libgtest_main.a && /usr/bin/llvm-ar-15 qc lib/RelWithDebInfo/libgtest_main.a  extern/googletest/googletest/CMakeFiles/gtest_main.dir/RelWithDebInfo/src/gtest_main.cc.o && /usr/bin/llvm-ranlib-15 lib/RelWithDebInfo/libgtest_main.a && :
[30/32] : && /usr/bin/clang++-15 -std=c++20    -Wall    -stdlib=libc++  -O3 -g -DNDEBUG  src/scratch/CMakeFiles/scratch_test.dir/RelWithDebInfo/scratch.t.cpp.o -o src/scratch/RelWithDebInfo/scratch_test  src/scratch/RelWithDebInfo/libscratch.a  lib/RelWithDebInfo/libgtest.a  lib/RelWithDebInfo/libgtest_main.a  lib/RelWithDebInfo/libgtest.a && cd /home/sdowney/src/papers/cppnow23/cmake.bld/sender-examples/build-clang-15/src/scratch && /usr/bin/cmake -D TEST_TARGET=scratch_test -D TEST_EXECUTABLE=/home/sdowney/src/papers/cppnow23/cmake.bld/sender-examples/build-clang-15/src/scratch/RelWithDebInfo/scratch_test -D TEST_EXECUTOR= -D TEST_WORKING_DIR=/home/sdowney/src/papers/cppnow23/cmake.bld/sender-examples/build-clang-15/src/scratch -D TEST_EXTRA_ARGS= -D TEST_PROPERTIES= -D TEST_PREFIX= -D TEST_SUFFIX= -D TEST_FILTER= -D NO_PRETTY_TYPES=FALSE -D NO_PRETTY_VALUES=FALSE -D TEST_LIST=scratch_test_TESTS -D CTEST_FILE=/home/sdowney/src/papers/cppnow23/cmake.bld/sender-examples/build-clang-15/src/scratch/scratch_test[1]_tests.cmake -D TEST_DISCOVERY_TIMEOUT=5 -D TEST_XML_OUTPUT_DIR= -P /usr/share/cmake-3.25/Modules/GoogleTestAddTests.cmake
[31/32] : && /usr/bin/clang++-15 -std=c++20    -Wall    -stdlib=libc++  -O3 -g -DNDEBUG  src/tree/CMakeFiles/tree_test.dir/RelWithDebInfo/tree.t.cpp.o -o src/tree/RelWithDebInfo/tree_test  src/tree/RelWithDebInfo/libtree.a  lib/RelWithDebInfo/libgtest.a  lib/RelWithDebInfo/libgtest_main.a  lib/RelWithDebInfo/libgtest.a && cd /home/sdowney/src/papers/cppnow23/cmake.bld/sender-examples/build-clang-15/src/tree && /usr/bin/cmake -D TEST_TARGET=tree_test -D TEST_EXECUTABLE=/home/sdowney/src/papers/cppnow23/cmake.bld/sender-examples/build-clang-15/src/tree/RelWithDebInfo/tree_test -D TEST_EXECUTOR= -D TEST_WORKING_DIR=/home/sdowney/src/papers/cppnow23/cmake.bld/sender-examples/build-clang-15/src/tree -D TEST_EXTRA_ARGS= -D TEST_PROPERTIES= -D TEST_PREFIX= -D TEST_SUFFIX= -D TEST_FILTER= -D NO_PRETTY_TYPES=FALSE -D NO_PRETTY_VALUES=FALSE -D TEST_LIST=tree_test_TESTS -D CTEST_FILE=/home/sdowney/src/papers/cppnow23/cmake.bld/sender-examples/build-clang-15/src/tree/tree_test[1]_tests.cmake -D TEST_DISCOVERY_TIMEOUT=5 -D TEST_XML_OUTPUT_DIR= -P /usr/share/cmake-3.25/Modules/GoogleTestAddTests.cmake
[32/32] : && /usr/bin/clang++-15 -std=c++20    -Wall    -stdlib=libc++  -O3 -g -DNDEBUG  src/examples/CMakeFiles/async_test.dir/RelWithDebInfo/async.t.cpp.o -o src/examples/RelWithDebInfo/async_test  lib/RelWithDebInfo/libgtest.a  lib/RelWithDebInfo/libgtest_main.a  lib/RelWithDebInfo/libgtest.a && cd /home/sdowney/src/papers/cppnow23/cmake.bld/sender-examples/build-clang-15/src/examples && /usr/bin/cmake -D TEST_TARGET=async_test -D TEST_EXECUTABLE=/home/sdowney/src/papers/cppnow23/cmake.bld/sender-examples/build-clang-15/src/examples/RelWithDebInfo/async_test -D TEST_EXECUTOR= -D TEST_WORKING_DIR=/home/sdowney/src/papers/cppnow23/cmake.bld/sender-examples/build-clang-15/src/examples -D TEST_EXTRA_ARGS= -D TEST_PROPERTIES= -D TEST_PREFIX= -D TEST_SUFFIX= -D TEST_FILTER= -D NO_PRETTY_TYPES=FALSE -D NO_PRETTY_VALUES=FALSE -D TEST_LIST=async_test_TESTS -D CTEST_FILE=/home/sdowney/src/papers/cppnow23/cmake.bld/sender-examples/build-clang-15/src/examples/async_test[1]_tests.cmake -D TEST_DISCOVERY_TIMEOUT=5 -D TEST_XML_OUTPUT_DIR= -P /usr/share/cmake-3.25/Modules/GoogleTestAddTests.cmake
cd ../cmake.bld/sender-examples/build-clang-15 && ctest --output-on-failure
Test project /home/sdowney/src/papers/cppnow23/cmake.bld/sender-examples/build-clang-15
    Start 1: TreeTest.TestGTest
1/9 Test #1: TreeTest.TestGTest ...............   Passed    0.00 sec
    Start 2: TreeTest.Breathing
2/9 Test #2: TreeTest.Breathing ...............   Passed    0.00 sec
    Start 3: TreeTest.construct
3/9 Test #3: TreeTest.construct ...............   Passed    0.00 sec
    Start 4: TreeTest.stress
4/9 Test #4: TreeTest.stress ..................   Passed    0.01 sec
    Start 5: ScratchTest.TestGTest
5/9 Test #5: ScratchTest.TestGTest ............   Passed    0.00 sec
    Start 6: ScratchTest.Breathing
6/9 Test #6: ScratchTest.Breathing ............   Passed    0.00 sec
    Start 7: AsyncTest.TestGTest
7/9 Test #7: AsyncTest.TestGTest ..............   Passed    0.00 sec
    Start 8: AsyncTest.Breathing
8/9 Test #8: AsyncTest.Breathing ..............   Passed    0.00 sec
    Start 9: AsyncTest.Factorial
9/9 Test #9: AsyncTest.Factorial ..............   Passed    0.00 sec

100% tests passed, 0 tests failed out of 9

Total Test time (real) =   0.03 sec
make[1]: Leaving directory '/home/sdowney/src/papers/cppnow23/sender-examples'
make -f targets.mk test CONFIG= TOOLCHAIN=clang-15
make[1]: Entering directory '/home/sdowney/src/papers/cppnow23/sender-examples'
cmake --build ../cmake.bld/sender-examples/build-clang-15  --config RelWithDebInfo --target all -v -- -k 0
ninja: no work to do.
cd ../cmake.bld/sender-examples/build-clang-15 && ctest --output-on-failure
Test project /home/sdowney/src/papers/cppnow23/cmake.bld/sender-examples/build-clang-15
    Start 1: TreeTest.TestGTest
1/9 Test #1: TreeTest.TestGTest ...............   Passed    0.00 sec
    Start 2: TreeTest.Breathing
2/9 Test #2: TreeTest.Breathing ...............   Passed    0.00 sec
    Start 3: TreeTest.construct
3/9 Test #3: TreeTest.construct ...............   Passed    0.00 sec
    Start 4: TreeTest.stress
4/9 Test #4: TreeTest.stress ..................   Passed    0.01 sec
    Start 5: ScratchTest.TestGTest
5/9 Test #5: ScratchTest.TestGTest ............   Passed    0.00 sec
    Start 6: ScratchTest.Breathing
6/9 Test #6: ScratchTest.Breathing ............   Passed    0.00 sec
    Start 7: AsyncTest.TestGTest
7/9 Test #7: AsyncTest.TestGTest ..............   Passed    0.00 sec
    Start 8: AsyncTest.Breathing
8/9 Test #8: AsyncTest.Breathing ..............   Passed    0.00 sec
    Start 9: AsyncTest.Factorial
9/9 Test #9: AsyncTest.Factorial ..............   Passed    0.00 sec

100% tests passed, 0 tests failed out of 9

Total Test time (real) =   0.03 sec
make[1]: Leaving directory '/home/sdowney/src/papers/cppnow23/sender-examples'
make -f targets.mk install CONFIG= TOOLCHAIN=clang-15
make[1]: Entering directory '/home/sdowney/src/papers/cppnow23/sender-examples'
echo INSTALL
INSTALL
DESTDIR=/home/sdowney/src/papers/cppnow23/install ninja -C ../cmake.bld/sender-examples/build-clang-15 -k 0  install
ninja: Entering directory `../cmake.bld/sender-examples/build-clang-15'
[0/1] Install the project...
-- Install configuration: "RelWithDebInfo"
-- Installing: /home/sdowney/src/papers/cppnow23/install/lib/cmake/SenderExamplesTargets.cmake
-- Installing: /home/sdowney/src/papers/cppnow23/install/lib/cmake/SenderExamplesTargets-relwithdebinfo.cmake
-- Installing: /home/sdowney/src/papers/cppnow23/install/lib/cmake/SenderExamplesConfig.cmake
-- Installing: /home/sdowney/src/papers/cppnow23/install/lib/cmake/SenderExamplesConfigVersion.cmake
-- Installing: /home/sdowney/src/papers/cppnow23/install/lib/libtree.a
-- Up-to-date: /home/sdowney/src/papers/cppnow23/install/include/senderexamples
-- Up-to-date: /home/sdowney/src/papers/cppnow23/install/include/senderexamples/tree.h
-- Installing: /home/sdowney/src/papers/cppnow23/install/lib/libscratch.a
-- Up-to-date: /home/sdowney/src/papers/cppnow23/install/include/senderexamples
-- Up-to-date: /home/sdowney/src/papers/cppnow23/install/include/senderexamples/scratch.h
-- Installing: /home/sdowney/src/papers/cppnow23/install/bin/main
-- Installing: /home/sdowney/src/papers/cppnow23/install/bin/hello
-- Installing: /home/sdowney/src/papers/cppnow23/install/bin/concurent
-- Installing: /home/sdowney/src/papers/cppnow23/install/bin/let_value
-- Installing: /home/sdowney/src/papers/cppnow23/install/bin/decision
-- Installing: /home/sdowney/src/papers/cppnow23/install/bin/factorial
-- Installing: /home/sdowney/src/papers/cppnow23/install/bin/fibonacci
-- Up-to-date: /home/sdowney/src/papers/cppnow23/install/bin/main
-- Up-to-date: /home/sdowney/src/papers/cppnow23/install/bin/hello
-- Up-to-date: /home/sdowney/src/papers/cppnow23/install/bin/concurent
-- Up-to-date: /home/sdowney/src/papers/cppnow23/install/bin/let_value
-- Up-to-date: /home/sdowney/src/papers/cppnow23/install/bin/decision
-- Up-to-date: /home/sdowney/src/papers/cppnow23/install/bin/factorial
-- Up-to-date: /home/sdowney/src/papers/cppnow23/install/bin/fibonacci
-- Installing: /home/sdowney/src/papers/cppnow23/install/bin/fold
-- Installing: /home/sdowney/src/papers/cppnow23/install/bin/backtrack
make[1]: Leaving directory '/home/sdowney/src/papers/cppnow23/sender-examples'
#+end_example

#+name: hello
#+BEGIN_SRC shell :exports results :results output :wrap example
./install/bin/hello
#+end_src

#+name: decision
#+BEGIN_SRC shell :exports results :results output :wrap example
./install/bin/decision
#+end_src


#+name: concurent
#+BEGIN_SRC shell :exports results :results output :wrap example
./install/bin/concurent
#+end_src



#+name: factorial
#+BEGIN_SRC shell :exports results :results output :wrap example
./install/bin/factorial
#+end_src


#+name: fibonacci
#+BEGIN_SRC shell :exports results :results output :wrap example
./install/bin/fibonacci
#+end_src

#+name: fold
#+BEGIN_SRC shell :exports results :results output :wrap example
./install/bin/fold
#+end_src


#+name: backtrack
#+BEGIN_SRC shell :exports results :results output :wrap example
./install/bin/backtrack
#+end_src


#+NAME: tangle-buffer
#+HEADERS: :exports none :results none
#+BEGIN_SRC emacs-lisp
(org-babel-tangle)
#+END_SRC
