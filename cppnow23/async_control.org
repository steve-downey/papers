#+OPTIONS: ':nil *:t -:t ::t <:t H:nil \n:nil ^:nil arch:headline author:nil
#+OPTIONS: broken-links:nil c:nil creator:nil d:(not "LOGBOOK") date:nil e:t
#+OPTIONS: email:nil f:t inline:t num:nil p:nil pri:nil prop:nil stat:t tags:t
#+OPTIONS: tasks:t tex:t timestamp:nil title:t toc:nil todo:t |:t
#+TITLE:
#+AUTHOR:
#+EMAIL:
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS:
#+LATEX_HEADER:
#+LATEX_HEADER_EXTRA:
#+DESCRIPTION:
#+KEYWORDS:
#+SUBTITLE:
#+LATEX_COMPILER: pdflatex
#+DATE:
#+STARTUP: showall
#+OPTIONS: html-link-use-abs-url:nil html-postamble:nil html-preamble:tbla
#+OPTIONS: html-scripts:t html-style:t html5-fancy:nil tex:t
#+HTML_DOCTYPE: xhtml-strict
#+HTML_CONTAINER: div
#+DESCRIPTION:
#+KEYWORDS:
#+HTML_LINK_HOME:
#+HTML_LINK_UP:
#+HTML_MATHJAX:
#+HTML_HEAD:
#+HTML_HEAD_EXTRA:
#+SUBTITLE:
#+INFOJS_OPT:
#+OPTIONS: reveal_width:1600 reveal_height:900
#+REVEAL_TRANS: fade
#+REVEAL_MATHJAX_URL: https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="./vivendi-tinted.css" />
#+REVEAL_THEME: ./my_theme.css
#+REVEAL_EXTRA_CSS: ./vivendi-tinted.css
#+REVEAL_EXTRA_CSS: ./footer.css
#+REVEAL_TITLE_SLIDE_BACKGROUND: ./async_title.png

#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js
#+REVEAL_VERSION: 4

#+REVEAL_HLEVEL: 2
#+REVEAL_EXPORT_NOTES_TO_PDF: separate-page

* Using Sender/Receiver for Async Control Flow

  Steve Downey

  Â© 2021 Bloomberg Finance L.P. All rights reserved.

* Abstract

How can P2300 Senders be composed using sender adapters and sender factories to provide arbitrary progam control flow?

   #+ATTR_REVEAL: :frag (appear)
   - How do I use these things?

#+begin_notes

#+end_notes

* ~std::execution~

https://isocpp.org/files/papers/P2300R7.html

#+begin_quote
A self-contained design for a Standard C++ framework for managing asynchronous execution on generic execution resources.
#+end_quote

#+begin_notes

#+end_notes

** Three Key Abstractions
   #+ATTR_REVEAL: :frag (appear)
1. Schedulers
   #+ATTR_REVEAL: :frag (appear)
2. Senders
   #+ATTR_REVEAL: :frag (appear)
3. Receivers

*** Schedulers
Responsible for scheduling work on execution resources.

Execution resources are things like threads, GPUs, and so on.

Sends work to be done in a place.


#+begin_notes

#+end_notes

*** Senders
Senders describe work.

#+begin_notes

#+end_notes

*** Receiver

Recievers are where work terminates.

   #+ATTR_REVEAL: :frag (appear)
- Value channel
   #+ATTR_REVEAL: :frag (appear)
- Error channel
   #+ATTR_REVEAL: :frag (appear)
- Stopped channel

#+begin_notes
Work can terminate in three different ways.
- Return a value.
- Throw an exception
- Be cancelled

It's been a few minutes. Lets see some simple code.
#+end_notes

*** Hello Async World

#+begin_src C++ -n :tangle ./sender-examples/src/examples/hello.cpp :comments link

#include <stdexec/execution.hpp>
#include <exec/static_thread_pool.hpp>
#include <iostream>

int main() {
  exec::static_thread_pool pool(8);

  stdexec::scheduler auto sch = pool.get_scheduler();

  stdexec::sender auto begin = stdexec::schedule(sch);
  stdexec::sender auto hi    = stdexec::then(begin, [] {
    std::cout << "Hello world! Have an int.\n";
    return 13;
  });

  auto add_42 = stdexec::then(hi, [](int arg) { return arg + 42; });

  auto [i] = stdexec::sync_wait(add_42).value();

  std::cout << "The int is " << i << '\n';

  return i;
}

#+end_src


[[https://godbolt.org/z/1M5enroaE][Compiler Explorer]]

*** Hello Async World Results

#+RESULTS: hello
#+begin_example
Hello world! Have an int.
#+end_example


*** When All - Concurent Async

#+BEGIN_SRC c++ :exports none :tangle ./sender-examples/src/examples/concurent.cpp :comments link
#include <stdexec/execution.hpp>
#include <exec/static_thread_pool.hpp>

int main()
{
#+END_SRC

#+begin_src c++ -n :tangle ./sender-examples/src/examples/concurent.cpp :comments link :exports code
exec::static_thread_pool pool(3);

auto sched = pool.get_scheduler();

auto fun = [](int i) { return i * i; };

auto work = stdexec::when_all(
    stdexec::on(sched, stdexec::just(0) | stdexec::then(fun)),
    stdexec::on(sched, stdexec::just(1) | stdexec::then(fun)),
    stdexec::on(sched, stdexec::just(2) | stdexec::then(fun)));

auto [i, j, k] = stdexec::sync_wait(std::move(work)).value();

std::printf("%d %d %d\n", i, j, k);
#+end_src

#+BEGIN_SRC c++ :exports none :tangle ./sender-examples/src/examples/concurent.cpp :comments link
}
#+END_SRC


#+begin_notes
  // Describe some work:

  // Creates 3 sender pipelines that are executed concurrently by passing to `when_all`

  // Each sender is scheduled on `sched` using `on` and starts with `just(n)` that creates a

  // Sender that just forwards `n` to the next sender.

  // After `just(n)`, we chain `then(fun)` which invokes `fun` using the value provided from `just()`

  // Note: No work actually happens here. Everything is lazy and `work` is just an object that statically

  // represents the work to later be executed

#+end_notes

*** When All - Concurent Async - Results

#+RESULTS: concurent
#+begin_example
0 1 4
#+end_example

#+begin_notes
Order of execution is by chance, order of results is determined.
#+end_notes

*** Dynamic Choice of Sender

#+BEGIN_SRC c++ :exports none :tangle ./sender-examples/src/examples/let_value.cpp :comments link
#include <stdexec/execution.hpp>
#include <exec/static_thread_pool.hpp>
#include <string>

int main()
{
#+END_SRC

#+begin_src c++ -n :tangle ./sender-examples/src/examples/let_value.cpp :comments link :exports code
exec::static_thread_pool pool(3);

auto sched = pool.get_scheduler();

auto fun = [](int i) -> stdexec::sender auto {
  using namespace std::string_literals;
  if ((i % 2) == 0) {
    return stdexec::just("even"s);
  } else {
    return stdexec::just("odd"s);
  }
};

auto work = stdexec::when_all(
    stdexec::on(sched, stdexec::just(0) | stdexec::let_value(fun)),
    stdexec::on(sched, stdexec::just(1) | stdexec::let_value(fun)),
    stdexec::on(sched, stdexec::just(2) | stdexec::let_value(fun)));

auto [i, j, k] = stdexec::sync_wait(std::move(work)).value();

std::printf("%s %s %s", i.c_str(), j.c_str(), k.c_str());
#+end_src

#+BEGIN_SRC c++ :exports none :tangle ./sender-examples/src/examples/let_value.cpp :comments link
}
#+END_SRC


https://godbolt.org/z/7vx69cMj9

#+RESULTS:

#+begin_notes

#+end_notes

*** Enough API to talk about control flow

The minimal set being:

- stdexec::on
- stdexec::just
- stdexec::then
- stdexec::let_value
- stdexec::sync_wait

  I will mostly ignore the error and stop channels

#+begin_notes

#+end_notes

* Vigorous Handwaving

** Some Theory

Continuation Passing Style

*** Not At All New

Sussman and Steele in 1975

AI Memo 349: "Scheme: An Interpreter for Extended Lambda Calculus"

#+begin_notes

#+end_notes

*** Pass a "Continuation"

Where to go next rather than return the value.

#+begin_src haskell
add :: Float -> Float -> Float
add a b = a + b

add_cps :: Float -> Float -> (Float -> a) -> a
add_cps a b cont = cont (a + b)
#+end_src

#+REVEAL: split

#+begin_src c++
auto add(float a, float b) -> float {
    return a + b;
}

template<typename Cont>
auto add_cps(float a, float b, Cont k) {
    return k(a+b);
}
#+end_src

#+begin_notes

#+end_notes

*** Inherently a tail call

In continuation passing style we never return.

We send a value to the rest of the program.

Hard to express in C++.

Extra machinery necessary to do the plumbing.

#+begin_notes

#+end_notes

*** Intermittently Popular as a Compiler Technique

The transformations of direct functions to CPS are mechanical.

The result is easier to optimize and mechanically reason about.

Equivalent to Single Static Assignment.

Structured Programming can be converted to CPS.

#+begin_notes

#+end_notes

*** Underlies ~std::execution~

The plumbing is hidden.

Senders "send" to their continuations, delimted by the Reciever.

#+begin_notes

#+end_notes

** Another Level of Indiretion

*** Solves all problems

Adds two more.

*** CPS Indirects Function Return

Transform a function

A -> B

to

B -> (B -> R) -> R

The A is (mostly) erased from the Sender.

** In which we use the M word

*** Sender is a Monad
(surprise)
*** Function Composition is the hint
Functions are units of work.

We compose them into programs.

The question is if the rules apply.

*** Monadic Interface

- bind or and_then ::
  \begin{equation}
  M \langle a \rangle \rightarrow (a \rightarrow M \langle b \rangle ) \rightarrow M \langle b \rangle
  \end{equation}

- fish or kleisli arrow  ::
  \begin{equation}
  (a \rightarrow M \langle b \rangle ) \rightarrow (b \rightarrow M \langle c \rangle ) \rightarrow (a \rightarrow M \langle c \rangle )
  \end{equation}

- join or flatten or mconcat ::
  \begin{equation}
  M \langle M \langle a \rangle \rangle \rightarrow  M \langle a \rangle
  \end{equation}

#+begin_notes
Monad Interface
#+end_notes
*** Applicative and Functor parts
- make or pure or return ::
  \begin{equation}
  a  \rightarrow  M \langle a \rangle
  \end{equation}

- fmap or transform ::
   \begin{equation}
    (a \rightarrow b) \rightarrow M \langle a \rangle \rightarrow M \langle b \rangle
   \end{equation}

Any one of the first three and one of the second two can define the other three

#+begin_notes
Monad Interface
#+end_notes
*** Monad Laws

- left identity :: bind(pure(a), h) == h(a)
- right identity :: bind(m, pure) == m
- associativity :: bind(bind(m, g), h) == bind(m, bind((\x -> g(x), h))

#+begin_notes
Monad Laws
#+end_notes

*** Sender is Three Monads in a Trenchcoat

Stacked up.

- Value
- Error
- Stopped

  #+begin_notes
The three channels can be crossed, mixed, and remixed. Focus on the value channel for simplicity.
#+end_notes

** The Three Parts
*** ~just~
Send a value.

~pure~

#+begin_notes
just lifts a value into the monad
#+end_notes

*** ~then~
Send a value returned from a function that takes its argument from a Sender.

~fmap~ or ~transform~

#+begin_notes
then is the functor fmap
#+end_notes

*** ~let_value~
Send what is returned by a Sender returned from a function that takes its argument from a Sender.

~bind~

#+begin_notes
let value is the monadic bind
#+end_notes

*** Necessary and Sufficient

The mondic bind gives us the runtime choices we need.

** Basis of Control
- Sequence
- Decision
- Recursion

*** Sequence

#+begin_src c++ -n
  stdexec::sender auto work =
      stdexec::schedule(sch)
      | stdexec::then([] {
          std::cout << "Hello world! Have an int.";
          return 13;
      })
      | stdexec::then([](int arg) { return arg + 42; });

  auto [i] = stdexec::sync_wait(work).value();
#+end_src

#+begin_notes
One thing after another.
#+end_notes

*** Decision
#+BEGIN_SRC c++ :exports none :tangle ./sender-examples/src/examples/decision.cpp :comments link
#include <stdexec/execution.hpp>
#include <exec/static_thread_pool.hpp>
#include <exec/any_sender_of.hpp>
#include <exec/variant_sender.hpp>
#include <iostream>

template <class... Ts>
using any_sender_of =
    typename exec::any_receiver_ref<
        stdexec::completion_signatures<Ts...>>::
        template any_sender<>;

inline auto tst = [](bool                 cond,
                     stdexec::sender auto left,
                     stdexec::sender auto right)
    -> exec::variant_sender<decltype(left),
                            decltype(right)> {
  if (cond)
    return left;
  else
    return right;
};

int main() {
#+END_SRC

#+begin_src c++ -n :tangle ./sender-examples/src/examples/decision.cpp :comments link :exports code
exec::static_thread_pool pool(8);

stdexec::scheduler auto sch = pool.get_scheduler();

stdexec::sender auto begin  = stdexec::schedule(sch);
stdexec::sender auto seven  = stdexec::just(7);
stdexec::sender auto eleven = stdexec::just(11);

stdexec::sender auto branch =
    begin
    | stdexec::then([]() { return std::make_tuple(5, 4); })
    | stdexec::let_value(
        [=](auto tpl) {
        auto const& [i, j] = tpl;

        return tst((i > j),
                   seven | stdexec::then([&](int k) noexcept {
                       std::cout << "true branch " << k << '\n';
                   }),
                   eleven | stdexec::then([&](int k) noexcept {
                       std::cout << "false branch " << k << '\n';
                   }));
    });

stdexec::sync_wait(std::move(branch));
#+end_src

#+BEGIN_SRC c++ :exports none :tangle ./sender-examples/src/examples/decision.cpp :comments link
}
#+END_SRC

#+begin_notes
Control what sender is sent at rentime depending on the state of the program when the work is executing rather than in the structure of the senders.
#+end_notes

**** tst function
#+BEGIN_SRC c++ -n :exports code

inline auto tst =
    [](bool                 cond,
       stdexec::sender auto left,
       stdexec::sender auto right) -> any_sender_of<stdexec::set_value_t()> {
    if (cond)
        return left;
    else
        return right;
};


#+END_SRC

*** Recursion

**** Simple Recursion
#+begin_src c++ :exports none :tangle ./sender-examples/src/examples/factorial.cpp :comments link
#include <cassert>
#include <stdexec/execution.hpp>
#include <exec/static_thread_pool.hpp>
#include <exec/any_sender_of.hpp>
#include <iostream>

template <class... Ts>
using any_sender_of = typename exec::any_receiver_ref<
    stdexec::completion_signatures<Ts...>>::template any_sender<>;

using any_int_sender =
    any_sender_of<stdexec::set_value_t(int),
                  stdexec::set_stopped_t(),
                  stdexec::set_error_t(std::exception_ptr)>;

auto eager_fac(int n) -> any_int_sender {
    std::cout << "factorial of " << n << "\n";
    if (n == 0)
        return stdexec::just(1);
    return eager_fac(n - 1) | stdexec::then([n](int k) { return k * n; });
}

#+END_SRC

#+begin_src c++ -n :tangle ./sender-examples/src/examples/factorial.cpp :comments link :exports code

auto fac(int n) -> any_int_sender {
    std::cout << "factorial of " << n << "\n";
    if (n == 0)
        return stdexec::just(1);

    return stdexec::just(n - 1)
        | stdexec::let_value([](int k) { return fac(k); })
        | stdexec::then([n](int k) { return k * n; });
}

#+end_src

#+BEGIN_SRC c++ :exports none :tangle ./sender-examples/src/examples/factorial.cpp :comments link

int main() {
    exec::static_thread_pool pool(8);

    stdexec::scheduler auto sch = pool.get_scheduler();

    stdexec::sender auto begin = stdexec::schedule(sch);

    std::cout << "factorial direct\n";
    auto check = fac(9);
    std::cout << "fac(9) returned\n";

#+END_SRC

#+REVEAL: split

#+begin_src c++ -n :tangle ./sender-examples/src/examples/factorial.cpp :comments link :exports code

    int                  k = 10;
    stdexec::sender auto factorial =
        begin
        | stdexec::then([=]() { return k; })
        | stdexec::let_value([](int k) { return fac(k); });

    std::cout << "factorial built\n";

    auto [i] = stdexec::sync_wait(std::move(factorial)).value();
    std::cout << "factorial " << k << " = " << i << '\n';
#+end_src

#+BEGIN_SRC c++ :exports none :tangle ./sender-examples/src/examples/factorial.cpp :comments link
    }

#+END_SRC

**** General Recursion
#+begin_src c++ :exports none :tangle ./sender-examples/src/examples/fibonacci.cpp :comments link
#include <cassert>
#include <stdexec/execution.hpp>
#include <exec/static_thread_pool.hpp>
#include <exec/any_sender_of.hpp>
#include <iostream>

template <class... Ts>
using any_sender_of = typename exec::any_receiver_ref<
    stdexec::completion_signatures<Ts...>>::template any_sender<>;

using any_int_sender = any_sender_of<stdexec::set_value_t(int),
                                     stdexec::set_stopped_t(),
                                     stdexec::set_error_t(std::exception_ptr)>;

#+END_SRC

#+begin_src c++ -n :tangle ./sender-examples/src/examples/fibonacci.cpp :comments link :exports code
auto fib(int n) -> any_int_sender {
    if (n == 0)
        return stdexec::just(0);

    if (n == 1)
        return stdexec::just(1);

    auto work =
        stdexec::when_all(stdexec::just(n - 1)
                          | stdexec::let_value([](int k) {
                              return fib(k);
                          }),
                          stdexec::just(n - 2)
                          | stdexec::let_value([](int k) {
                              return fib(k);
                          }))
        | stdexec::then([](auto i, auto j) { return i + j; });

    return work;
}

#+end_src

#+BEGIN_SRC c++ :exports none :tangle ./sender-examples/src/examples/fibonacci.cpp :comments link

auto fibr(int n) -> int {
    if (n == 0)
        return 0;

    if (n == 1)
        return 1;

    return fibr(n - 1) + fibr(n - 2);
}

int main() {
    exec::static_thread_pool pool(1);

    stdexec::scheduler auto sch = pool.get_scheduler();

    stdexec::sender auto begin = stdexec::schedule(sch);

#+END_SRC

#+REVEAL: split

#+begin_src c++ -n :tangle ./sender-examples/src/examples/fibonacci.cpp :comments link :exports code
    int                  k = 36;
    stdexec::sender auto fibonacci =
        begin | stdexec::then([=]() { return k; }) |
        stdexec::let_value([](int k) { return fib(k); });

    std::cout << "fibonacci built\n";

    auto [i] = stdexec::sync_wait(std::move(fibonacci)).value();
    std::cout << "fibonacci " << k << " = " << i << '\n';
#+end_src

#+BEGIN_SRC c++ :exports none :tangle ./sender-examples/src/examples/fibonacci.cpp :comments link

    std::cout << "fibonacci " << k << " = " << fibr(k) << '\n';
}
#+end_src


**** Fold
#+begin_src c++ :exports none :tangle ./sender-examples/src/examples/fold.cpp :comments link
#include <cassert>
#include <stdexec/execution.hpp>
#include <exec/static_thread_pool.hpp>
#include <exec/any_sender_of.hpp>
#include <iostream>
#include <ranges>

template <class... Ts>
using any_sender_of = typename exec::any_receiver_ref<
    stdexec::completion_signatures<Ts...>>::template any_sender<>;

using any_int_sender = any_sender_of<stdexec::set_value_t(int),
                                     stdexec::set_stopped_t(),
                                     stdexec::set_error_t(std::exception_ptr)>;

struct fold_left_fn {
    template <std::input_iterator I, std::sentinel_for<I> S, class T, class F>
    constexpr auto operator()(I first, S last, T init, F f) const
        -> any_sender_of<
            stdexec::set_value_t(
                std::decay_t<
                    std::invoke_result_t<F&, T, std::iter_reference_t<I>>>),
            stdexec::set_stopped_t(),
            stdexec::set_error_t(std::exception_ptr)> {
        using U = std::decay_t<
            std::invoke_result_t<F&, T, std::iter_reference_t<I>>>;
#+END_SRC

#+begin_src c++ -n :tangle ./sender-examples/src/examples/fold.cpp :comments link :exports code

        if (first == last) {
            return stdexec::just(U(std::move(init)));
        }

        auto nxt =
            stdexec::just(std::invoke(f, std::move(init), *first)) |
            stdexec::let_value([this,
                                first = first,
                                last = last,
                                f = f
                                ](U u) {
                I i = first;
                return (*this)(++i, last, u, f);
            });
        return std::move(nxt);
#+end_src

#+BEGIN_SRC c++ :exports none :tangle ./sender-examples/src/examples/fold.cpp :comments link
    }

    template <std::ranges::input_range R, class T, class F>
    constexpr auto operator()(R&& r, T init, F f) const {
        return (*this)(std::ranges::begin(r),
                       std::ranges::end(r),
                       std::move(init),
                       std::ref(f));
    }
};

inline constexpr fold_left_fn fold_left;

int main() {
    exec::static_thread_pool pool(1);

    stdexec::scheduler auto sch = pool.get_scheduler();

    stdexec::sender auto begin = stdexec::schedule(sch);
#+END_SRC

#+REVEAL: split

#+begin_src c++ -n :tangle ./sender-examples/src/examples/fold.cpp :comments link :exports code

    auto v = std::ranges::iota_view{1, 10'000};

    stdexec::sender auto work =
        begin
        | stdexec::let_value([i = std::ranges::begin(v),
                              s = std::ranges::end(v)]() {
            return fold_left(i, s, 0, [](int i, int j) { return i + j; });
        });

    auto [i] = stdexec::sync_wait(std::move(work)).value();

#+end_src

#+BEGIN_SRC c++ :exports none :tangle ./sender-examples/src/examples/fold.cpp :comments link
    std::cout << "work " << " = " << i << '\n';
}
#+end_src

**** Backtrack
#+begin_src c++ :exports none :tangle ./sender-examples/src/examples/backtrack.cpp :comments link
#include <cassert>

#include <stdexec/execution.hpp>
#include <exec/static_thread_pool.hpp>
#include <exec/any_sender_of.hpp>
#include <tree/tree.h>

#include <iostream>
#include <ranges>

template <class... Ts>
using any_sender_of = typename exec::any_receiver_ref<
    stdexec::completion_signatures<Ts...>>::template any_sender<>;

using any_int_sender = any_sender_of<stdexec::set_value_t(int),
                                     stdexec::set_stopped_t(),
                                     stdexec::set_error_t(std::exception_ptr)>;
#+end_src


#+begin_src c++ :exports code :tangle ./sender-examples/src/examples/backtrack.cpp :comments link
using any_node_sender =
    any_sender_of<stdexec::set_value_t(tree::NodePtr<int>),
                  stdexec::set_stopped_t(),
                  stdexec::set_error_t(std::exception_ptr)>;

any_node_sender search_tree(auto                    test,
                            tree::NodePtr<int>      tree,
                            stdexec::scheduler auto sch,
                            any_node_sender&&       fail) {
    if (tree == nullptr) {
        return std::move(fail);
    }
    if (test(tree)) {
        return stdexec::just(tree);
    }
    return stdexec::on(sch, stdexec::just()) |
           stdexec::let_value([=, fail = std::move(fail)]() mutable {
               return search_tree(
                   test,
                   tree->left(),
                   sch,
                   stdexec::on(sch, stdexec::just()) |
                       stdexec::let_value(
                           [=, fail = std::move(fail)]() mutable {
                               return search_tree(
                                   test, tree->right(), sch, std::move(fail));
                           }));
           });
    return fail;
}
#+end_src

#+REVEAL: split

#+begin_src c++ :exports none :tangle ./sender-examples/src/examples/backtrack.cpp :comments link
int main() {
    exec::static_thread_pool pool(8);

    stdexec::scheduler auto sch = pool.get_scheduler();

    stdexec::sender auto begin = stdexec::schedule(sch);
#+end_src

#+begin_src c++ :tangle ./sender-examples/src/examples/backtrack.cpp :comments link :exports code
    tree::NodePtr<int> t;
    for (auto i : std::ranges::views::iota(1, 10'000)) {
        tree::Tree<int>::insert(i, t);
    }

    auto test = [](tree::NodePtr<int> t) -> bool {
        return t ? t->data() == 500 : false;
    };

    auto fail = begin | stdexec::then([]() { return tree::NodePtr<int>{}; });

    stdexec::sender auto work =
        begin | stdexec::let_value([=]() {
            return search_tree(test, t, sch, std::move(fail));
        });

    auto [n] = stdexec::sync_wait(std::move(work)).value();

    std::cout << "work "
              << " = " << n->data() << '\n';
#+end_src

#+begin_src c++ :exports none :tangle ./sender-examples/src/examples/backtrack.cpp :comments link
}
#+end_src
* Don't Do That
** Can is not Should
** Write an Algorithm
** Why You Might
- Throughput
- Interruptable



* Thank You

* Tangle before export                                             :noexport:
To retangle the document, run `C-c C-v t` or eval the last src block

#+NAME: run-build
#+BEGIN_SRC sh :exports both :results output
cd sender-examples
make realclean TOOLCHAIN=clang-15
make TOOLCHAIN=clang-15
make test TOOLCHAIN=clang-15
make install TOOLCHAIN=clang-15
#+END_SRC

#+RESULTS: run-build
#+begin_example
make -f targets.mk realclean CONFIG= TOOLCHAIN=clang-15
make[1]: Entering directory '/home/sdowney/src/sdowney/papers/cppnow23/sender-examples'
rm -rf ../cmake.bld/sender-examples/build-clang-15
make[1]: Leaving directory '/home/sdowney/src/sdowney/papers/cppnow23/sender-examples'
make -f targets.mk test CONFIG= TOOLCHAIN=clang-15
make[1]: Entering directory '/home/sdowney/src/sdowney/papers/cppnow23/sender-examples'
mkdir -p ../cmake.bld/sender-examples/build-clang-15
cd ../cmake.bld/sender-examples/build-clang-15 && 	cmake -G "Ninja Multi-Config" -DCMAKE_CONFIGURATION_TYPES="RelWithDebInfo;Debug;Tsan;Asan" -DCMAKE_INSTALL_PREFIX= -DCMAKE_EXPORT_COMPILE_COMMANDS=1 -DCMAKE_TOOLCHAIN_FILE=/home/sdowney/src/sdowney/papers/cppnow23/sender-examples/etc/clang-15-toolchain.cmake /home/sdowney/src/sdowney/papers/cppnow23/sender-examples
-- The CXX compiler identification is Clang 15.0.7
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Check for working CXX compiler: /usr/bin/clang++-15 - skipped
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- The C compiler identification is Clang 15.0.7
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working C compiler: /usr/bin/clang-15 - skipped
-- Detecting C compile features
-- Detecting C compile features - done
-- Found Python: /usr/bin/python3.9 (found version "3.9.5") found components: Interpreter
-- Performing Test CMAKE_HAVE_LIBC_PTHREAD
-- Performing Test CMAKE_HAVE_LIBC_PTHREAD - Failed
-- Looking for pthread_create in pthreads
-- Looking for pthread_create in pthreads - not found
-- Looking for pthread_create in pthread
-- Looking for pthread_create in pthread - found
-- Found Threads: TRUE
-- Configuring incomplete, errors occurred!
make[1]: Leaving directory '/home/sdowney/src/sdowney/papers/cppnow23/sender-examples'
make -f targets.mk test CONFIG= TOOLCHAIN=clang-15
make[1]: Entering directory '/home/sdowney/src/sdowney/papers/cppnow23/sender-examples'
cmake --build ../cmake.bld/sender-examples/build-clang-15  --config RelWithDebInfo --target all -v -- -k 0
make[1]: Leaving directory '/home/sdowney/src/sdowney/papers/cppnow23/sender-examples'
make -f targets.mk install CONFIG= TOOLCHAIN=clang-15
make[1]: Entering directory '/home/sdowney/src/sdowney/papers/cppnow23/sender-examples'
echo INSTALL
INSTALL
DESTDIR=/home/sdowney/src/sdowney/papers/cppnow23/install ninja -C ../cmake.bld/sender-examples/build-clang-15 -k 0  install
ninja: Entering directory `../cmake.bld/sender-examples/build-clang-15'
make[1]: Leaving directory '/home/sdowney/src/sdowney/papers/cppnow23/sender-examples'
#+end_example

#+name: hello
#+BEGIN_SRC shell :exports results :results output :wrap example
./install/bin/hello
#+end_src

#+name: decision
#+BEGIN_SRC shell :exports results :results output :wrap example
./install/bin/decision
#+end_src

#+RESULTS: decision
#+begin_example
true branch 7
#+end_example

#+name: concurent
#+BEGIN_SRC shell :exports results :results output :wrap example
./install/bin/concurent
#+end_src



#+name: factorial
#+BEGIN_SRC shell :exports results :results output :wrap example
./install/bin/factorial
#+end_src

#+RESULTS: factorial
#+begin_example
factorial direct
factorial of 9
fac(9) returned
factorial built
factorial of 10
factorial of 9
factorial of 8
factorial of 7
factorial of 6
factorial of 5
factorial of 4
factorial of 3
factorial of 2
factorial of 1
factorial of 0
factorial 10 = 3628800
#+end_example

#+name: fibonacci
#+BEGIN_SRC shell :exports results :results output :wrap example
./install/bin/fibonacci
#+end_src

#+RESULTS: fibonacci
#+begin_example
fibonacci built
fibonacci 36 = 14930352
fibonacci 36 = 14930352
#+end_example

#+name: backtrack
#+BEGIN_SRC shell :exports results :results output :wrap example
./install/bin/backtrack
#+end_src

#+RESULTS: backtrack
#+begin_example
#+end_example

#+NAME: tangle-buffer
#+HEADERS: :exports none :results none
#+BEGIN_SRC emacs-lisp
(org-babel-tangle)
#+END_SRC
